Disassembly Listing for EncoderBaySlave
Generated From:
/home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/dist/default/production/EncoderBaySlave.X.production.elf
Mar 24, 2017 4:49:52 PM

---  /home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/mcc_generated_files/tmr0.c  ------------
1:             /**
2:               TMR0 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr0.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR0 driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This source file provides APIs for TMR0.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC18F46K40
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:             */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:             */
45:            
46:            /**
47:              Section: Included Files
48:             */
49:            
50:            #include <xc.h>
51:            #include "tmr0.h"
52:            #include "pin_manager.h"
53:            
54:            /**
55:              Section: TMR0 APIs
56:             */
57:            
58:            void (*TMR0_InterruptHandler)(void);
59:            
60:            void TMR0_Initialize(void) {
61:                // Set TMR0 to the options selected in the User Interface
62:            
63:                // T0OUTPS 1:1; T0EN disabled; T016BIT 8-bit;
64:                T0CON0 = 0x00;
073C  0E00     MOVLW 0x0
073E  6ED5     MOVWF T0CON0, ACCESS
65:            
66:                // T0CS FOSC/4; T0CKPS 1:64; T0ASYNC synchronised; 
67:                T0CON1 = 0x46;
0740  0E46     MOVLW 0x46
0742  6ED6     MOVWF T0CON1, ACCESS
68:            
69:                // TMR0H 249; 
70:                TMR0H = 0xF9;
0744  0EF9     MOVLW 0xF9
0746  6ED4     MOVWF TMR0H, ACCESS
71:            
72:                // TMR0L 0;
73:                TMR0L = 0x00;
0748  0E00     MOVLW 0x0
074A  6ED3     MOVWF TMR0L, ACCESS
74:            
75:                // Clear Interrupt flag before enabling the interrupt
76:                PIR0bits.TMR0IF = 0;
074C  010E     MOVLB 0xE
074E  9BCA     BCF 0xCA, 5, BANKED
77:            
78:                // Enabling TMR0 interrupt.
79:                PIE0bits.TMR0IE = 1;
0750  010E     MOVLB 0xE
0752  8BC2     BSF 0xC2, 5, BANKED
80:            
81:                // Set Default Interrupt Handler
82:                TMR0_SetInterruptHandler(TMR0_DefaultInterruptHandler);
0754  0E30     MOVLW 0x30
0756  0100     MOVLB 0x0
0758  6F88     MOVWF __pcstackBANK0, BANKED
075A  0E08     MOVLW 0x8
075C  0100     MOVLB 0x0
075E  6F89     MOVWF pwm, BANKED
0760  EC0B     CALL 0x816, 0
0762  F004     NOP
83:            
84:                // Start TMR0
85:                TMR0_StartTimer();
0764  EC14     CALL 0x828, 0
0766  F004     NOP
86:            }
0768  0012     RETURN 0
87:            
88:            void TMR0_StartTimer(void) {
89:                // Start the Timer by writing to TMR0ON bit
90:                T0CON0bits.T0EN = 1;
0828  8ED5     BSF T0CON0, 7, ACCESS
91:            }
082A  0012     RETURN 0
92:            
93:            void TMR0_StopTimer(void) {
94:                // Stop the Timer by writing to TMR0ON bit
95:                T0CON0bits.T0EN = 0;
96:            }
97:            
98:            uint8_t TMR0_Read8bitTimer(void) {
99:                uint8_t readVal;
100:           
101:               // read Timer0, low register only
102:               readVal = TMR0L;
103:           
104:               return readVal;
105:           }
106:           
107:           void TMR0_Write8bitTimer(uint8_t timerVal) {
108:               // Write to Timer0 registers, low register only
109:               TMR0L = timerVal;
110:           }
111:           
112:           void TMR0_Load8bitPeriod(uint8_t periodVal) {
113:               // Write to Timer0 registers, high register only
114:               TMR0H = periodVal;
115:           }
116:           
117:           void TMR0_ISR(void) {
118:               // clear the TMR0 interrupt flag
119:               PIR0bits.TMR0IF = 0;
0794  010E     MOVLB 0xE
0796  9BCA     BCF 0xCA, 5, BANKED
120:               if (TMR0_InterruptHandler) {
0798  504E     MOVF TMR0_InterruptHandler, W, ACCESS
079A  104F     IORWF 0x4F, W, ACCESS
079C  B4D8     BTFSC STATUS, 2, ACCESS
079E  0012     RETURN 0
121:                   TMR0_InterruptHandler();
07A0  D801     RCALL 0x7A4
07A2  0012     RETURN 0
07A4  0005     PUSH
07A6  6EFA     MOVWF PCLATH, ACCESS
07A8  504E     MOVF TMR0_InterruptHandler, W, ACCESS
07AA  6EFD     MOVWF TOS, ACCESS
07AC  504F     MOVF 0x4F, W, ACCESS
07AE  6EFE     MOVWF TOSH, ACCESS
07B0  50F8     MOVF TBLPTRU, W, ACCESS
07B2  6EFF     MOVWF TOSU, ACCESS
07B4  50FA     MOVF PCLATH, W, ACCESS
07B6  0012     RETURN 0
122:               }
123:           
124:               // add your TMR0 interrupt custom code
125:           }
126:           
127:           void TMR0_SetInterruptHandler(void* InterruptHandler) {
128:               TMR0_InterruptHandler = InterruptHandler;
0816  C088     MOVFF __pcstackBANK0, TMR0_InterruptHandler
0818  F04E     NOP
081A  C089     MOVFF pwm, 0x4F
081C  F04F     NOP
129:           }
081E  0012     RETURN 0
130:           
131:           void TMR0_DefaultInterruptHandler(void) {
132:               // add your TMR0 interrupt custom code
133:               // or set custom function using TMR0_SetInterruptHandler()
134:           }
0830  0012     RETURN 0
135:           
136:           /**
137:             End of File
138:            */
---  /home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/mcc_generated_files/pin_manager.c  -----
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using MPLAB(c) Code Configurator
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC18F46K40
18:                    Driver Version    :  1.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            
25:                Microchip licenses to you the right to use, modify, copy and distribute
26:                Software only when embedded on a Microchip microcontroller or digital signal
27:                controller that is integrated into your product or third party product
28:                (pursuant to the sublicense terms in the accompanying license agreement).
29:            
30:                You should refer to the license agreement accompanying this Software for
31:                additional information regarding your rights and obligations.
32:            
33:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:            
44:            */
45:            
46:            #include <xc.h>
47:            #include "pin_manager.h"
48:            #include "stdbool.h"
49:            
50:            
51:            void PIN_MANAGER_Initialize(void)
52:            {
53:                /**
54:                LATx registers
55:                */   
56:                LATE = 0x02;    
040E  0E02     MOVLW 0x2
0410  6E87     MOVWF LATE, ACCESS
57:                LATD = 0x00;    
0412  0E00     MOVLW 0x0
0414  6E86     MOVWF LATD, ACCESS
58:                LATA = 0x00;    
0416  0E00     MOVLW 0x0
0418  6E83     MOVWF LATA, ACCESS
59:                LATB = 0x00;    
041A  0E00     MOVLW 0x0
041C  6E84     MOVWF LATB, ACCESS
60:                LATC = 0x00;    
041E  0E00     MOVLW 0x0
0420  6E85     MOVWF LATC, ACCESS
61:            
62:                /**
63:                TRISx registers
64:                */    
65:                TRISE = 0x04;
0422  0E04     MOVLW 0x4
0424  6E8C     MOVWF TRISE, ACCESS
66:                TRISA = 0xFF;
0426  6888     SETF TRISA, ACCESS
67:                TRISB = 0xC3;
0428  0EC3     MOVLW 0xC3
042A  6E89     MOVWF TRISB, ACCESS
68:                TRISC = 0xFF;
042C  688A     SETF TRISC, ACCESS
69:                TRISD = 0xFF;
042E  688B     SETF TRISD, ACCESS
70:            
71:                /**
72:                ANSELx registers
73:                */   
74:                ANSELC = 0x00;
0430  0E00     MOVLW 0x0
0432  010F     MOVLB 0xF
0434  6F21     MOVWF 0x21, BANKED
75:                ANSELB = 0xC0;
0436  0EC0     MOVLW 0xC0
0438  010F     MOVLB 0xF
043A  6F19     MOVWF i2c_10bit_address_restart, BANKED
76:                ANSELD = 0x00;
043C  0E00     MOVLW 0x0
043E  010F     MOVLB 0xF
0440  6F26     MOVWF 0x26, BANKED
77:                ANSELE = 0x04;
0442  0E04     MOVLW 0x4
0444  010F     MOVLB 0xF
0446  6F2E     MOVWF 0x2E, BANKED
78:                ANSELA = 0x00;
0448  0E00     MOVLW 0x0
044A  010F     MOVLB 0xF
044C  6F11     MOVWF p_i2c1_trb_current, BANKED
79:            
80:                /**
81:                WPUx registers
82:                */ 
83:                WPUD = 0xFF;
044E  010F     MOVLB 0xF
0450  6925     SETF 0x25, BANKED
84:                WPUE = 0x00;
0452  0E00     MOVLW 0x0
0454  010F     MOVLB 0xF
0456  6F2D     MOVWF 0x2D, BANKED
85:                WPUB = 0x03;
0458  0E03     MOVLW 0x3
045A  010F     MOVLB 0xF
045C  6F18     MOVWF buttonState, BANKED
86:                WPUA = 0x00;
045E  0E00     MOVLW 0x0
0460  010F     MOVLB 0xF
0462  6F10     MOVWF 0x10, BANKED
87:                WPUC = 0xFF;
0464  010F     MOVLB 0xF
0466  6920     SETF 0x20, BANKED
88:            
89:                /**
90:                ODx registers
91:                */   
92:                ODCONE = 0x00;
0468  0E00     MOVLW 0x0
046A  010F     MOVLB 0xF
046C  6F2C     MOVWF 0x2C, BANKED
93:                ODCONA = 0x00;
046E  0E00     MOVLW 0x0
0470  010F     MOVLB 0xF
0472  6F0F     MOVWF p_i2c1_current, BANKED
94:                ODCONB = 0x00;
0474  0E00     MOVLW 0x0
0476  010F     MOVLB 0xF
0478  6F17     MOVWF buttonPressed, BANKED
95:                ODCONC = 0x00;
047A  0E00     MOVLW 0x0
047C  010F     MOVLB 0xF
047E  6F1F     MOVWF 0x1F, BANKED
96:                ODCOND = 0x00;
0480  0E00     MOVLW 0x0
0482  010F     MOVLB 0xF
0484  6F24     MOVWF 0x24, BANKED
97:                
98:            
99:            
100:              
101:               
102:               
103:               bool state = GIE;
0486  0E00     MOVLW 0x0
0488  BEF2     BTFSC INTCON, 7, ACCESS
048A  0E01     MOVLW 0x1
048C  0100     MOVLB 0x0
048E  6F88     MOVWF __pcstackBANK0, BANKED
104:               GIE = 0;
0490  9EF2     BCF INTCON, 7, ACCESS
105:               PPSLOCK = 0x55;
0492  0E55     MOVLW 0x55
0494  010E     MOVLB 0xE
0496  6FA0     MOVWF 0xA0, BANKED
106:               PPSLOCK = 0xAA;
0498  0EAA     MOVLW 0xAA
049A  010E     MOVLB 0xE
049C  6FA0     MOVWF 0xA0, BANKED
107:               PPSLOCKbits.PPSLOCKED = 0x00; // unlock PPS
049E  010E     MOVLB 0xE
04A0  91A0     BCF 0xA0, 0, BANKED
108:           
109:               SSP1CLKPPSbits.SSPCLKPPS = 0x08;   //RB0->MSSP1:SCL1;
04A2  010E     MOVLB 0xE
04A4  91B7     BCF 0xB7, 0, BANKED
04A6  93B7     BCF 0xB7, 1, BANKED
04A8  95B7     BCF 0xB7, 2, BANKED
04AA  87B7     BSF 0xB7, 3, BANKED
04AC  99B7     BCF 0xB7, 4, BANKED
110:               RB1PPS = 0x10;   //RB1->MSSP1:SDA1;
04AE  0E10     MOVLW 0x10
04B0  010E     MOVLB 0xE
04B2  6FF0     MOVWF 0xF0, BANKED
111:               RB0PPS = 0x0F;   //RB0->MSSP1:SCL1;
04B4  0E0F     MOVLW 0xF
04B6  010E     MOVLB 0xE
04B8  6FEF     MOVWF 0xEF, BANKED
112:               SSP1DATPPSbits.SSPDATPPS = 0x09;   //RB1->MSSP1:SDA1;
04BA  010E     MOVLB 0xE
04BC  81B8     BSF 0xB8, 0, BANKED
04BE  93B8     BCF 0xB8, 1, BANKED
04C0  95B8     BCF 0xB8, 2, BANKED
04C2  87B8     BSF 0xB8, 3, BANKED
04C4  99B8     BCF 0xB8, 4, BANKED
113:           
114:               PPSLOCK = 0x55;
04C6  0E55     MOVLW 0x55
04C8  010E     MOVLB 0xE
04CA  6FA0     MOVWF 0xA0, BANKED
115:               PPSLOCK = 0xAA;
04CC  0EAA     MOVLW 0xAA
04CE  010E     MOVLB 0xE
04D0  6FA0     MOVWF 0xA0, BANKED
116:               PPSLOCKbits.PPSLOCKED = 0x01; // lock PPS
04D2  010E     MOVLB 0xE
04D4  81A0     BSF 0xA0, 0, BANKED
117:           
118:               GIE = state;
04D6  0100     MOVLB 0x0
04D8  A188     BTFSS __pcstackBANK0, 0, BANKED
04DA  D002     BRA 0x4E0
04DC  8EF2     BSF INTCON, 7, ACCESS
04DE  0012     RETURN 0
04E0  9EF2     BCF INTCON, 7, ACCESS
119:           }       
04E2  0012     RETURN 0
120:           
121:           void PIN_MANAGER_IOC(void)
122:           {   
123:           
124:           }
125:           
126:           /**
127:            End of File
128:           */
---  /home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/mcc_generated_files/mcc.c  -------------
1:             /**
2:               @Generated MPLAB(c) Code Configurator Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using MPLAB(c) Code Configurator
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC18F46K40
18:                    Driver Version    :  1.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            // Configuration bits: selected in the GUI
47:            
48:            // CONFIG1L
49:            #pragma config FEXTOSC = OFF    // ->Oscillator not enabled
50:            #pragma config RSTOSC = HFINTOSC_64MHZ    // ->HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1
51:            
52:            // CONFIG1H
53:            #pragma config CLKOUTEN = OFF    // ->CLKOUT function is disabled
54:            #pragma config CSWEN = ON    // ->Writing to NOSC and NDIV is allowed
55:            #pragma config FCMEN = ON    // Fail-Safe Clock Monitor Enable bit->Fail-Safe Clock Monitor enabled
56:            
57:            // CONFIG2L
58:            #pragma config MCLRE = EXTMCLR    // ->If LVP = 0, MCLR pin is MCLR; If LVP = 1, RE3 pin function is MCLR 
59:            #pragma config PWRTE = OFF    // Power-up Timer Enable bit->Power up timer disabled
60:            #pragma config LPBOREN = OFF    // ->ULPBOR disabled
61:            #pragma config BOREN = SBORDIS    // Brown-out Reset Enable bits->Brown-out Reset enabled , SBOREN bit is ignored
62:            
63:            // CONFIG2H
64:            #pragma config BORV = VBOR_2P45    // Brown Out Reset Voltage selection bits->Brown-out Reset Voltage (VBOR) set to 2.45V
65:            #pragma config ZCD = OFF    // ZCD Disable bit->ZCD disabled. ZCD can be enabled by setting the ZCDSEN bit of ZCDCON
66:            #pragma config PPS1WAY = ON    // PPSLOCK bit One-Way Set Enable bit->PPSLOCK bit can be cleared and set only once; PPS registers remain locked after one clear/set cycle
67:            #pragma config STVREN = ON    // Stack Full/Underflow Reset Enable bit->Stack full/underflow will cause Reset
68:            #pragma config DEBUG = OFF    // Debugger Enable bit->Background debugger disabled
69:            #pragma config XINST = OFF    // Extended Instruction Set Enable bit->Extended Instruction Set and Indexed Addressing Mode disabled
70:            
71:            // CONFIG3L
72:            #pragma config WDTCPS = WDTCPS_31    // ->Divider ratio 1:65536; software control of WDTPS
73:            #pragma config WDTE = OFF    // WDT operating mode->WDT Disabled
74:            
75:            // CONFIG3H
76:            #pragma config WDTCWS = WDTCWS_7    // WDT Window Select bits->window always open (100%); software control; keyed access not required
77:            #pragma config WDTCCS = SC    // WDT input clock selector->Software Control
78:            
79:            // CONFIG4L
80:            #pragma config WRT0 = OFF    // Write Protection Block 0->Block 0 (000800-003FFFh) not write-protected
81:            #pragma config WRT1 = OFF    // Write Protection Block 1->Block 1 (004000-007FFFh) not write-protected
82:            #pragma config WRT2 = OFF    // Write Protection Block 2->Block 2 (008000-00BFFFh) not write-protected
83:            #pragma config WRT3 = OFF    // Write Protection Block 3->Block 3 (00C000-00FFFFh) not write-protected
84:            
85:            // CONFIG4H
86:            #pragma config WRTC = OFF    // Configuration Register Write Protection bit->Configuration registers (300000-30000Bh) not write-protected
87:            #pragma config WRTB = OFF    // Boot Block Write Protection bit->Boot Block (000000-0007FFh) not write-protected
88:            #pragma config WRTD = OFF    // Data EEPROM Write Protection bit->Data EEPROM not write-protected
89:            #pragma config SCANE = ON    // ->Scanner module is available for use, SCANMD bit can control the module
90:            #pragma config LVP = ON    // Low Voltage Programming Enable bit->Low voltage programming enabled. MCLR/VPP pin function is MCLR. MCLRE configuration bit is ignored
91:            
92:            // CONFIG5L
93:            #pragma config CP = OFF    // UserNVM Program Memory Code Protection bit->UserNVM code protection disabled
94:            #pragma config CPD = OFF    // DataNVM Memory Code Protection bit->DataNVM code protection disabled
95:            
96:            // CONFIG6L
97:            #pragma config EBTR0 = OFF    // Table Read Protection Block 0->Block 0 (000800-003FFFh) not protected from table reads executed in other blocks
98:            #pragma config EBTR1 = OFF    // Table Read Protection Block 1->Block 1 (004000-007FFFh) not protected from table reads executed in other blocks
99:            #pragma config EBTR2 = OFF    // Table Read Protection Block 2->Block 2 (008000-00BFFFh) not protected from table reads executed in other blocks
100:           #pragma config EBTR3 = OFF    // Table Read Protection Block 3->Block 3 (00C000-00FFFFh) not protected from table reads executed in other blocks
101:           
102:           // CONFIG6H
103:           #pragma config EBTRB = OFF    // Boot Block Table Read Protection bit->Boot Block (000000-0007FFh) not protected from table reads executed in other blocks
104:           
105:           #include "mcc.h"
106:           
107:           void SYSTEM_Initialize(void)
108:           {
109:           
110:               INTERRUPT_Initialize();
07F0  EC16     CALL 0x82C, 0
07F2  F004     NOP
111:               PIN_MANAGER_Initialize();
07F4  EC07     CALL 0x40E, 0
07F6  F002     NOP
112:               OSCILLATOR_Initialize();
07F8  ECDC     CALL 0x7B8, 0
07FA  F003     NOP
113:               I2C1_Initialize();
07FC  EC6D     CALL 0x6DA, 0
07FE  F003     NOP
114:               TMR0_Initialize();
0800  EC9E     CALL 0x73C, 0
0802  F003     NOP
115:           }
0804  0012     RETURN 0
116:           
117:           void OSCILLATOR_Initialize(void)
118:           {
119:               // NOSC HFINTOSC; NDIV 1; 
120:               OSCCON1 = 0x60;
07B8  0E60     MOVLW 0x60
07BA  010E     MOVLB 0xE
07BC  6FD8     MOVWF 0xD8, BANKED
121:               // CSWHOLD may proceed; SOSCPWR Low power; 
122:               OSCCON3 = 0x00;
07BE  0E00     MOVLW 0x0
07C0  010E     MOVLB 0xE
07C2  6FDA     MOVWF 0xDA, BANKED
123:               // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
124:               OSCEN = 0x00;
07C4  0E00     MOVLW 0x0
07C6  010E     MOVLB 0xE
07C8  6FDC     MOVWF 0xDC, BANKED
125:               // HFFRQ 64_MHz; 
126:               OSCFRQ = 0x08;
07CA  0E08     MOVLW 0x8
07CC  010E     MOVLB 0xE
07CE  6FDE     MOVWF 0xDE, BANKED
127:               // TUN 0; 
128:               OSCTUNE = 0x00;
07D0  0E00     MOVLW 0x0
07D2  010E     MOVLB 0xE
07D4  6FDD     MOVWF 0xDD, BANKED
129:               // Set the secondary oscillator
130:               
131:           }
07D6  0012     RETURN 0
132:           
133:           
134:           /**
135:            End of File
136:           */
---  /home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/mcc_generated_files/interrupt_manager.c  
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using MPLAB(c) Code Configurator
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
19:                    Device            :  PIC18F46K40
20:                    Driver Version    :  1.02
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 1.35
23:                    MPLAB             :  MPLAB X 3.40
24:            */
25:            
26:            /*
27:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
28:                software and any derivatives exclusively with Microchip products.
29:            
30:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
31:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
32:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
33:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
34:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
35:            
36:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:            
44:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
45:                TERMS.
46:            */
47:            
48:            #include "interrupt_manager.h"
49:            #include "mcc.h"
50:            
51:            void  INTERRUPT_Initialize (void)
52:            {
53:                // Disable Interrupt Priority Vectors (16CXXX Compatibility Mode)
54:                INTCONbits.IPEN = 0;
082C  9AF2     BCF INTCON, 5, ACCESS
55:            }
082E  0012     RETURN 0
56:            
57:            void interrupt INTERRUPT_InterruptManager (void)
0008  8250     BSF btemp, 1, ACCESS
000A  CFFA     MOVFF PCLATH, 0x38
000C  F038     NOP
000E  CFFB     MOVFF PCLATU, 0x39
0010  F039     NOP
0012  CFE9     MOVFF FSR0, 0x3A
0014  F03A     NOP
0016  CFEA     MOVFF FSR0H, 0x3B
0018  F03B     NOP
001A  CFE1     MOVFF FSR1, 0x3C
001C  F03C     NOP
001E  CFE2     MOVFF FSR1H, 0x3D
0020  F03D     NOP
0022  CFD9     MOVFF FSR2, 0x3E
0024  F03E     NOP
0026  CFDA     MOVFF FSR2H, 0x3F
0028  F03F     NOP
002A  CFF3     MOVFF PROD, 0x40
002C  F040     NOP
002E  CFF4     MOVFF PRODH, 0x41
0030  F041     NOP
0032  CFF6     MOVFF TBLPTR, 0x42
0034  F042     NOP
0036  CFF7     MOVFF TBLPTRH, 0x43
0038  F043     NOP
003A  CFF8     MOVFF TBLPTRU, 0x44
003C  F044     NOP
003E  CFF5     MOVFF TABLAT, 0x45
0040  F045     NOP
58:            {
59:                // interrupt handler
60:                if(PIE0bits.TMR0IE == 1 && PIR0bits.TMR0IF == 1)
0042  010E     MOVLB 0xE
0044  ABC2     BTFSS 0xC2, 5, BANKED
0046  D006     BRA 0x54
0048  010E     MOVLB 0xE
004A  ABCA     BTFSS 0xCA, 5, BANKED
004C  D003     BRA 0x54
61:                {
62:                    TMR0_ISR();
004E  ECCA     CALL 0x794, 0
0050  F003     NOP
63:                }
0052  D014     BRA 0x7C
64:                else if(INTCONbits.PEIE == 1 && PIE3bits.BCL1IE == 1 && PIR3bits.BCL1IF == 1)
0054  ACF2     BTFSS INTCON, 6, ACCESS
0056  D009     BRA 0x6A
0058  010E     MOVLB 0xE
005A  A3C5     BTFSS 0xC5, 1, BANKED
005C  D006     BRA 0x6A
005E  010E     MOVLB 0xE
0060  A3CD     BTFSS 0xCD, 1, BANKED
0062  D003     BRA 0x6A
65:                {
66:                    I2C1_BusCollisionISR();
0064  EC19     CALL 0x832, 0
0066  F004     NOP
67:                }
0068  D009     BRA 0x7C
68:                else if(INTCONbits.PEIE == 1 && PIE3bits.SSP1IE == 1 && PIR3bits.SSP1IF == 1)
006A  ACF2     BTFSS INTCON, 6, ACCESS
006C  D007     BRA 0x7C
006E  010E     MOVLB 0xE
0070  A1C5     BTFSS 0xC5, 0, BANKED
0072  D004     BRA 0x7C
0074  010E     MOVLB 0xE
0076  B1CD     BTFSC 0xCD, 0, BANKED
69:                {
70:                    I2C1_ISR();
0078  EC5E     CALL 0xBC, 0
007A  F000     NOP
71:                }
72:                else
73:                {
74:                    //Unhandled Interrupt
75:                }
76:            }
007C  C045     MOVFF 0x45, TABLAT
007E  FFF5     NOP
0080  C044     MOVFF 0x44, TBLPTRU
0082  FFF8     NOP
0084  C043     MOVFF 0x43, TBLPTRH
0086  FFF7     NOP
0088  C042     MOVFF 0x42, TBLPTR
008A  FFF6     NOP
008C  C041     MOVFF 0x41, PRODH
008E  FFF4     NOP
0090  C040     MOVFF 0x40, PROD
0092  FFF3     NOP
0094  C03F     MOVFF 0x3F, FSR2H
0096  FFDA     NOP
0098  C03E     MOVFF 0x3E, FSR2
009A  FFD9     NOP
009C  C03D     MOVFF 0x3D, FSR1H
009E  FFE2     NOP
00A0  C03C     MOVFF 0x3C, FSR1
00A2  FFE1     NOP
00A4  C03B     MOVFF 0x3B, FSR0H
00A6  FFEA     NOP
00A8  C03A     MOVFF 0x3A, FSR0
00AA  FFE9     NOP
00AC  C039     MOVFF 0x39, PCLATU
00AE  FFFB     NOP
00B0  C038     MOVFF 0x38, PCLATH
00B2  FFFA     NOP
00B4  9250     BCF btemp, 1, ACCESS
00B6  0011     RETFIE 1
77:            /**
78:             End of File
79:            */
---  /home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/mcc_generated_files/i2c1.c  ------------
1:             /**
2:               I2C1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 i2c1.c
9:             
10:              @Summary
11:                This is the generated header file for the I2C1 driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This header file provides APIs for driver for I2C1.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC18F46K40
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB 	          :  MPLAB X 3.40
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            
50:            #include "i2c1.h"
51:            
52:            /**
53:              I2C Driver Queue Status Type
54:            
55:              @Summary
56:                Defines the type used for the transaction queue status.
57:            
58:              @Description
59:                This defines type used to keep track of the queue status.
60:             */
61:            
62:            typedef union
63:            {
64:                struct
65:                {
66:                        uint8_t full:1;
67:                        uint8_t empty:1;
68:                        uint8_t reserved:6;
69:                }s;
70:                uint8_t status;
71:            }I2C_TR_QUEUE_STATUS;
72:            
73:            /**
74:              I2C Driver Queue Entry Type
75:            
76:              @Summary
77:                Defines the object used for an entry in the i2c queue items.
78:            
79:              @Description
80:                This defines the object in the i2c queue. Each entry is a composed
81:                of a list of TRBs, the number of the TRBs and the status of the
82:                currently processed TRB.
83:             */
84:            typedef struct
85:            {
86:                uint8_t                             count;          // a count of trb's in the trb list
87:                I2C1_TRANSACTION_REQUEST_BLOCK *ptrb_list;     // pointer to the trb list
88:                I2C1_MESSAGE_STATUS            *pTrFlag;       // set with the error of the last trb sent.
89:                                                                    // if all trb's are sent successfully,
90:                                                                    // then this is I2C1_MESSAGE_COMPLETE
91:            } I2C_TR_QUEUE_ENTRY;
92:            
93:            /**
94:              I2C Master Driver Object Type
95:            
96:              @Summary
97:                Defines the object that manages the i2c master.
98:            
99:              @Description
100:               This defines the object that manages the sending and receiving of
101:               i2c master transactions.
102:             */
103:           
104:           typedef struct
105:           {
106:               /* Read/Write Queue */
107:               I2C_TR_QUEUE_ENTRY          *pTrTail;       // tail of the queue
108:               I2C_TR_QUEUE_ENTRY          *pTrHead;       // head of the queue
109:               I2C_TR_QUEUE_STATUS         trStatus;       // status of the last transaction
110:               uint8_t                         i2cDoneFlag;    // flag to indicate the current
111:                                                               // transaction is done
112:               uint8_t                         i2cErrors;      // keeps track of errors
113:           
114:           
115:           } I2C_OBJECT ;
116:           
117:           /**
118:             I2C Master Driver State Enumeration
119:           
120:             @Summary
121:               Defines the different states of the i2c master.
122:           
123:             @Description
124:               This defines the different states that the i2c master
125:               used to process transactions on the i2c bus.
126:           */
127:           
128:           typedef enum
129:           {
130:               S_MASTER_IDLE,
131:               S_MASTER_RESTART,
132:               S_MASTER_SEND_ADDR,
133:               S_MASTER_SEND_DATA,
134:               S_MASTER_SEND_STOP,
135:               S_MASTER_ACK_ADDR,
136:               S_MASTER_RCV_DATA,
137:               S_MASTER_RCV_STOP,
138:               S_MASTER_ACK_RCV_DATA,
139:               S_MASTER_NOACK_STOP,
140:               S_MASTER_SEND_ADDR_10BIT_LSB,
141:               S_MASTER_10BIT_RESTART,
142:               
143:           } I2C_MASTER_STATES;
144:           
145:           /**
146:            Section: Macro Definitions
147:           */
148:           
149:           /* defined for I2C1 */
150:           
151:           #ifndef I2C1_CONFIG_TR_QUEUE_LENGTH
152:                   #define I2C1_CONFIG_TR_QUEUE_LENGTH 1
153:           #endif
154:           
155:           #define I2C1_TRANSMIT_REG                       SSP1BUF                 // Defines the transmit register used to send data.
156:           #define I2C1_RECEIVE_REG                        SSP1BUF                 // Defines the receive register used to receive data.
157:           
158:           // The following control bits are used in the I2C state machine to manage
159:           // the I2C module and determine next states.
160:           #define I2C1_WRITE_COLLISION_STATUS_BIT         SSP1CON1bits.WCOL     // Defines the write collision status bit.
161:           #define I2C1_MODE_SELECT_BITS                   SSP1CON1bits.SSPM     // I2C Master Mode control bit.
162:           #define I2C1_MASTER_ENABLE_CONTROL_BITS         SSP1CON1bits.SSPEN    // I2C port enable control bit.
163:           
164:           #define I2C1_START_CONDITION_ENABLE_BIT         SSP1CON2bits.SEN      // I2C START control bit.
165:           #define I2C1_REPEAT_START_CONDITION_ENABLE_BIT  SSP1CON2bits.RSEN     // I2C Repeated START control bit.
166:           #define I2C1_RECEIVE_ENABLE_BIT                 SSP1CON2bits.RCEN     // I2C Receive enable control bit.
167:           #define I2C1_STOP_CONDITION_ENABLE_BIT          SSP1CON2bits.PEN      // I2C STOP control bit.
168:           #define I2C1_ACKNOWLEDGE_ENABLE_BIT             SSP1CON2bits.ACKEN    // I2C ACK start control bit.
169:           #define I2C1_ACKNOWLEDGE_DATA_BIT               SSP1CON2bits.ACKDT    // I2C ACK data control bit.
170:           #define I2C1_ACKNOWLEDGE_STATUS_BIT             SSP1CON2bits.ACKSTAT  // I2C ACK status bit.
171:           
172:           #define I2C1_7bit    true
173:           /**
174:            Section: Local Functions
175:           */
176:           
177:           void I2C1_FunctionComplete(void);
178:           void I2C1_Stop(I2C1_MESSAGE_STATUS completion_code);
179:           
180:           /**
181:            Section: Local Variables
182:           */
183:           
184:           static I2C_TR_QUEUE_ENTRY                  i2c1_tr_queue[I2C1_CONFIG_TR_QUEUE_LENGTH];
185:           static I2C_OBJECT                          i2c1_object;
186:           static I2C_MASTER_STATES                   i2c1_state = S_MASTER_IDLE;
187:           static uint8_t                                 i2c1_trb_count = 0;
188:           
189:           static I2C1_TRANSACTION_REQUEST_BLOCK       *p_i2c1_trb_current = NULL;
190:           static I2C_TR_QUEUE_ENTRY                  *p_i2c1_current = NULL;
191:           
192:           
193:           /**
194:             Section: Driver Interface
195:           */
196:           
197:           
198:           void I2C1_Initialize(void)
199:           {
200:               i2c1_object.pTrHead = i2c1_tr_queue;
06DA  0E29     MOVLW 0x29
06DC  6E03     MOVWF 0x3, ACCESS
06DE  0E00     MOVLW 0x0
06E0  6E04     MOVWF 0x4, ACCESS
201:               i2c1_object.pTrTail = i2c1_tr_queue;
06E2  0E29     MOVLW 0x29
06E4  6E01     MOVWF i2c1_object, ACCESS
06E6  0E00     MOVLW 0x0
06E8  6E02     MOVWF 0x2, ACCESS
202:               i2c1_object.trStatus.s.empty = true;
06EA  8205     BSF 0x5, 1, ACCESS
203:               i2c1_object.trStatus.s.full = false;
06EC  9005     BCF 0x5, 0, ACCESS
204:           
205:               i2c1_object.i2cErrors = 0;
06EE  0E00     MOVLW 0x0
06F0  6E07     MOVWF 0x7, ACCESS
206:           
207:               // SMP High Speed; CKE disabled; 
208:               SSP1STAT = 0x00;
06F2  0E00     MOVLW 0x0
06F4  6E95     MOVWF SSP1STAT, ACCESS
209:               // SSPEN enabled; CKP Idle:Low, Active:High; SSPM FOSC/4_SSPxADD_I2C; 
210:               SSP1CON1 = 0x28;
06F6  0E28     MOVLW 0x28
06F8  6E96     MOVWF SSP1CON1, ACCESS
211:               // SBCDE disabled; BOEN disabled; SCIE disabled; PCIE disabled; DHEN disabled; SDAHT 100ns; AHEN disabled; 
212:               SSP1CON3 = 0x00;
06FA  0E00     MOVLW 0x0
06FC  6E98     MOVWF SSP1CON3, ACCESS
213:               // Baud Rate Generator Value: SSPADD 39;   
214:               SSP1ADD = 0x27;
06FE  0E27     MOVLW 0x27
0700  6E93     MOVWF SSP1ADD, ACCESS
215:           
216:              
217:               // clear the master interrupt flag
218:               PIR3bits.SSP1IF = 0;
0702  010E     MOVLB 0xE
0704  91CD     BCF 0xCD, 0, BANKED
219:               // enable the master interrupt
220:               PIE3bits.SSP1IE = 1;
0706  010E     MOVLB 0xE
0708  81C5     BSF 0xC5, 0, BANKED
221:               
222:           }
070A  0012     RETURN 0
223:           
224:                   
225:           uint8_t I2C1_ErrorCountGet(void)
226:           {
227:               uint8_t ret;
228:           
229:               ret = i2c1_object.i2cErrors;
230:               return ret;
231:           }
232:           
233:           void I2C1_ISR ( void )
234:           {
235:             
236:               static uint8_t  *pi2c_buf_ptr;
237:               static uint16_t i2c_address         = 0;
238:               static uint8_t  i2c_bytes_left      = 0;
239:               static uint8_t  i2c_10bit_address_restart = 0;
240:           
241:               PIR3bits.SSP1IF = 0;
00BC  010E     MOVLB 0xE
00BE  91CD     BCF 0xCD, 0, BANKED
242:           
243:               // Check first if there was a collision.
244:               // If we have a Write Collision, reset and go to idle state */
245:               if(I2C1_WRITE_COLLISION_STATUS_BIT)
00C0  AE96     BTFSS SSP1CON1, 7, ACCESS
00C2  D0F9     BRA 0x2B6
246:               {
247:                   // clear the Write colision
248:                   I2C1_WRITE_COLLISION_STATUS_BIT = 0;
00C4  9E96     BCF SSP1CON1, 7, ACCESS
249:                   i2c1_state = S_MASTER_IDLE;
00C6  0E00     MOVLW 0x0
00C8  6E1C     MOVWF i2c1_state, ACCESS
250:                   *(p_i2c1_current->pTrFlag) = I2C1_MESSAGE_FAIL;
00CA  EE20     LFSR 2, 0x3
00CC  F003     NOP
00CE  500F     MOVF p_i2c1_current, W, ACCESS
00D0  26D9     ADDWF FSR2, F, ACCESS
00D2  5010     MOVF 0x10, W, ACCESS
00D4  22DA     ADDWFC FSR2H, F, ACCESS
00D6  CFDE     MOVFF POSTINC2, 0x34
00D8  F034     NOP
00DA  CFDD     MOVFF POSTDEC2, 0x35
00DC  F035     NOP
00DE  C034     MOVFF 0x34, FSR2
00E0  FFD9     NOP
00E2  C035     MOVFF 0x35, FSR2H
00E4  FFDA     NOP
00E6  0E01     MOVLW 0x1
00E8  6EDF     MOVWF INDF2, ACCESS
251:           
252:                   // reset the buffer pointer
253:                   p_i2c1_current = NULL;
00EA  0E00     MOVLW 0x0
00EC  6E0F     MOVWF p_i2c1_current, ACCESS
00EE  0E00     MOVLW 0x0
00F0  6E10     MOVWF 0x10, ACCESS
254:           
255:                   return;
00F2  0012     RETURN 0
256:               }
257:           
258:               /* Handle the correct i2c state */
259:               switch(i2c1_state)
02B6  501C     MOVF i2c1_state, W, ACCESS
260:               {
261:                   case S_MASTER_IDLE:    /* In reset state, waiting for data to send */
262:           
263:                       if(i2c1_object.trStatus.s.empty != true)
00F4  B205     BTFSC 0x5, 1, ACCESS
00F6  0012     RETURN 0
264:                       {
265:                           // grab the item pointed by the head
266:                           p_i2c1_current     = i2c1_object.pTrHead;
00F8  C003     MOVFF 0x3, p_i2c1_current
00FA  F00F     NOP
00FC  C004     MOVFF 0x4, 0x10
00FE  F010     NOP
267:                           i2c1_trb_count     = i2c1_object.pTrHead->count;
0100  C003     MOVFF 0x3, FSR2
0102  FFD9     NOP
0104  C004     MOVFF 0x4, FSR2H
0106  FFDA     NOP
0108  50DF     MOVF INDF2, W, ACCESS
010A  6E1B     MOVWF i2c1_trb_count, ACCESS
268:                           p_i2c1_trb_current = i2c1_object.pTrHead->ptrb_list;
010C  EE20     LFSR 2, 0x1
010E  F001     NOP
0110  5003     MOVF 0x3, W, ACCESS
0112  26D9     ADDWF FSR2, F, ACCESS
0114  5004     MOVF 0x4, W, ACCESS
0116  22DA     ADDWFC FSR2H, F, ACCESS
0118  CFDE     MOVFF POSTINC2, p_i2c1_trb_current
011A  F011     NOP
011C  CFDD     MOVFF POSTDEC2, 0x12
011E  F012     NOP
269:           
270:                           i2c1_object.pTrHead++;
0120  0E06     MOVLW 0x6
0122  2603     ADDWF 0x3, F, ACCESS
0124  0E00     MOVLW 0x0
0126  2204     ADDWFC 0x4, F, ACCESS
271:           
272:                           // check if the end of the array is reached
273:                           if(i2c1_object.pTrHead == (i2c1_tr_queue + I2C1_CONFIG_TR_QUEUE_LENGTH))
0128  0E2F     MOVLW 0x2F
012A  1803     XORWF 0x3, W, ACCESS
012C  E108     BNZ 0x13E
012E  0E00     MOVLW 0x0
0130  1804     XORWF 0x4, W, ACCESS
0132  A4D8     BTFSS STATUS, 2, ACCESS
0134  D004     BRA 0x13E
274:                           {
275:                               // adjust to restart at the beginning of the array
276:                               i2c1_object.pTrHead = i2c1_tr_queue;
0136  0E29     MOVLW 0x29
0138  6E03     MOVWF 0x3, ACCESS
013A  0E00     MOVLW 0x0
013C  6E04     MOVWF 0x4, ACCESS
277:                           }
278:           
279:                           // since we moved one item to be processed, we know
280:                           // it is not full, so set the full status to false
281:                           i2c1_object.trStatus.s.full = false;
013E  9005     BCF 0x5, 0, ACCESS
282:           
283:                           // check if the queue is empty
284:                           if(i2c1_object.pTrHead == i2c1_object.pTrTail)
0140  5001     MOVF i2c1_object, W, ACCESS
0142  1803     XORWF 0x3, W, ACCESS
0144  E104     BNZ 0x14E
0146  5002     MOVF 0x2, W, ACCESS
0148  1804     XORWF 0x4, W, ACCESS
014A  B4D8     BTFSC STATUS, 2, ACCESS
285:                           {
286:                               // it is empty so set the empty status to true
287:                               i2c1_object.trStatus.s.empty = true;
014C  8205     BSF 0x5, 1, ACCESS
288:                           }
289:           
290:                           // send the start condition
291:                           I2C1_START_CONDITION_ENABLE_BIT = 1;
014E  8097     BSF SSP1CON2, 0, ACCESS
292:                           
293:                           // start the i2c request
294:                           i2c1_state = S_MASTER_SEND_ADDR;
0150  0E02     MOVLW 0x2
0152  6E1C     MOVWF i2c1_state, ACCESS
295:                       }
296:           
297:                       break;
0154  0012     RETURN 0
298:           
299:                   case S_MASTER_RESTART:
300:           
301:                       /* check for pending i2c Request */
302:           
303:                       // ... trigger a REPEATED START
304:                       I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
0156  8297     BSF SSP1CON2, 1, ACCESS
305:           
306:                       // start the i2c request
307:                       i2c1_state = S_MASTER_SEND_ADDR;
0158  0E02     MOVLW 0x2
015A  6E1C     MOVWF i2c1_state, ACCESS
308:           
309:                       break;
015C  0012     RETURN 0
310:           
311:                   case S_MASTER_SEND_ADDR_10BIT_LSB:
312:           
313:                       if(I2C1_ACKNOWLEDGE_STATUS_BIT)
015E  AC97     BTFSS SSP1CON2, 6, ACCESS
0160  D005     BRA 0x16C
314:                       {
315:                           i2c1_object.i2cErrors++;
0162  2A07     INCF 0x7, F, ACCESS
316:                           I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
0164  0E04     MOVLW 0x4
0166  EC34     CALL 0x668, 0
0168  F003     NOP
317:                       }
016A  0012     RETURN 0
318:                       else
319:                       {
320:                           // Remove bit 0 as R/W is never sent here
321:                           I2C1_TRANSMIT_REG = (i2c_address >> 1) & 0x00FF;
016C  90D8     BCF STATUS, 0, ACCESS
016E  3030     RRCF 0x30, W, ACCESS
0170  6E35     MOVWF 0x35, ACCESS
0172  302F     RRCF i2c_address, W, ACCESS
0174  6E34     MOVWF 0x34, ACCESS
0176  5034     MOVF 0x34, W, ACCESS
0178  6E92     MOVWF SSP1BUF, ACCESS
322:           
323:                           // determine the next state, check R/W
324:                           if(i2c_address & 0x01)
017A  A02F     BTFSS i2c_address, 0, ACCESS
017C  D003     BRA 0x184
325:                           {
326:                               // if this is a read we must repeat start
327:                               // the bus to perform a read
328:                               i2c1_state = S_MASTER_10BIT_RESTART;
017E  0E0B     MOVLW 0xB
0180  6E1C     MOVWF i2c1_state, ACCESS
329:                           }
0182  0012     RETURN 0
330:                           else
331:                           {
332:                               // this is a write continue writing data
333:                               i2c1_state = S_MASTER_SEND_DATA;
0184  0E03     MOVLW 0x3
0186  6E1C     MOVWF i2c1_state, ACCESS
334:                           }
335:                       }
336:           
337:                       break;
0188  0012     RETURN 0
338:           
339:                   case S_MASTER_10BIT_RESTART:
340:           
341:                       if(I2C1_ACKNOWLEDGE_STATUS_BIT)
018A  AC97     BTFSS SSP1CON2, 6, ACCESS
018C  D005     BRA 0x198
342:                       {
343:                           i2c1_object.i2cErrors++;
018E  2A07     INCF 0x7, F, ACCESS
344:                           I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
0190  0E04     MOVLW 0x4
0192  EC34     CALL 0x668, 0
0194  F003     NOP
345:                       }
0196  0012     RETURN 0
346:                       else
347:                       {
348:                           // ACK Status is good
349:                           // restart the bus
350:                           I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
0198  8297     BSF SSP1CON2, 1, ACCESS
351:           
352:                           // fudge the address so S_MASTER_SEND_ADDR works correctly
353:                           // we only do this on a 10-bit address resend
354:                           i2c_address = 0x00F0 | ((i2c_address >> 8) & 0x0006);
019A  C02F     MOVFF i2c_address, 0x34
019C  F034     NOP
019E  C030     MOVFF 0x30, 0x35
01A0  F035     NOP
01A2  C035     MOVFF 0x35, 0x34
01A4  F034     NOP
01A6  6A35     CLRF 0x35, ACCESS
01A8  0E06     MOVLW 0x6
01AA  1634     ANDWF 0x34, F, ACCESS
01AC  0E00     MOVLW 0x0
01AE  1635     ANDWF 0x35, F, ACCESS
01B0  0EF0     MOVLW 0xF0
01B2  1034     IORWF 0x34, W, ACCESS
01B4  6E2F     MOVWF i2c_address, ACCESS
01B6  5035     MOVF 0x35, W, ACCESS
01B8  6E30     MOVWF 0x30, ACCESS
355:           
356:                           // set the R/W flag
357:                           i2c_address |= 0x0001;
01BA  802F     BSF i2c_address, 0, ACCESS
358:           
359:                           // set the address restart flag so we do not change the address
360:                           i2c_10bit_address_restart = 1;
01BC  0E01     MOVLW 0x1
01BE  6E19     MOVWF i2c_10bit_address_restart, ACCESS
361:           
362:                           // Resend the address as a read
363:                           i2c1_state = S_MASTER_SEND_ADDR;
01C0  0E02     MOVLW 0x2
01C2  6E1C     MOVWF i2c1_state, ACCESS
364:                       }
365:           
366:                       break;
01C4  0012     RETURN 0
367:           
368:                   case S_MASTER_SEND_ADDR:
369:           
370:                       /* Start has been sent, send the address byte */
371:           
372:                       /* Note: 
373:                           On a 10-bit address resend (done only during a 10-bit
374:                           device read), the original i2c_address was modified in
375:                           S_MASTER_10BIT_RESTART state. So the check if this is
376:                           a 10-bit address will fail and a normal 7-bit address
377:                           is sent with the R/W bit set to read. The flag
378:                           i2c_10bit_address_restart prevents the  address to
379:                           be re-written.
380:                        */
381:                       if(i2c_10bit_address_restart != 1)
01C6  0419     DECF i2c_10bit_address_restart, W, ACCESS
01C8  B4D8     BTFSC STATUS, 2, ACCESS
01CA  D01A     BRA 0x200
382:                       {
383:                           // extract the information for this message
384:                           i2c_address    = p_i2c1_trb_current->address;
01CC  C011     MOVFF p_i2c1_trb_current, FSR2
01CE  FFD9     NOP
01D0  C012     MOVFF 0x12, FSR2H
01D2  FFDA     NOP
01D4  CFDE     MOVFF POSTINC2, i2c_address
01D6  F02F     NOP
01D8  CFDD     MOVFF POSTDEC2, 0x30
01DA  F030     NOP
385:                           pi2c_buf_ptr   = p_i2c1_trb_current->pbuffer;
01DC  EE20     LFSR 2, 0x3
01DE  F003     NOP
01E0  5011     MOVF p_i2c1_trb_current, W, ACCESS
01E2  26D9     ADDWF FSR2, F, ACCESS
01E4  5012     MOVF 0x12, W, ACCESS
01E6  22DA     ADDWFC FSR2H, F, ACCESS
01E8  CFDE     MOVFF POSTINC2, pi2c_buf_ptr
01EA  F00D     NOP
01EC  CFDD     MOVFF POSTDEC2, 0xE
01EE  F00E     NOP
386:                           i2c_bytes_left = p_i2c1_trb_current->length;
01F0  EE20     LFSR 2, 0x2
01F2  F002     NOP
01F4  5011     MOVF p_i2c1_trb_current, W, ACCESS
01F6  26D9     ADDWF FSR2, F, ACCESS
01F8  5012     MOVF 0x12, W, ACCESS
01FA  22DA     ADDWFC FSR2H, F, ACCESS
01FC  50DF     MOVF INDF2, W, ACCESS
01FE  6E1A     MOVWF i2c_bytes_left, ACCESS
387:                       }
388:           
389:                       // check for 10-bit address
390:                       if(!I2C1_7bit && (0x0 != i2c_address))
391:                       {  
392:                           if (0 == i2c_10bit_address_restart)
393:                           {
394:                               // we have a 10 bit address
395:                               // send bits<9:8>
396:                               // mask bit 0 as this is always a write                    
397:                               I2C1_TRANSMIT_REG = 0xF0 | ((i2c_address >> 8) & 0x0006);
398:                               i2c1_state = S_MASTER_SEND_ADDR_10BIT_LSB;
399:                           }
400:                           else
401:                           {
402:                               // resending address bits<9:8> to trigger read
403:                               I2C1_TRANSMIT_REG = i2c_address;
404:                               i2c1_state = S_MASTER_ACK_ADDR;
405:                               // reset the flag so the next access is ok
406:                               i2c_10bit_address_restart = 0;
407:                           }
408:                       }
409:                       else
410:                       {
411:                           // Transmit the address
412:                           I2C1_TRANSMIT_REG = i2c_address;
0200  C02F     MOVFF i2c_address, SSP1BUF
0202  FF92     NOP
413:                           if(i2c_address & 0x01)
0204  A02F     BTFSS i2c_address, 0, ACCESS
0206  D003     BRA 0x20E
414:                           {
415:                               // Next state is to wait for address to be acked
416:                               i2c1_state = S_MASTER_ACK_ADDR;
0208  0E05     MOVLW 0x5
020A  6E1C     MOVWF i2c1_state, ACCESS
417:                           }
020C  0012     RETURN 0
418:                           else
419:                           {
420:                               // Next state is transmit
421:                               i2c1_state = S_MASTER_SEND_DATA;
020E  0E03     MOVLW 0x3
0210  6E1C     MOVWF i2c1_state, ACCESS
422:                           }
423:                       }
424:                       break;
0212  0012     RETURN 0
425:           
426:                   case S_MASTER_SEND_DATA:
427:           
428:                       // Make sure the previous byte was acknowledged
429:                       if(I2C1_ACKNOWLEDGE_STATUS_BIT)
0214  AC97     BTFSS SSP1CON2, 6, ACCESS
0216  D006     BRA 0x224
430:                       {
431:                           // Transmission was not acknowledged
432:                           i2c1_object.i2cErrors++;
0218  2A07     INCF 0x7, F, ACCESS
433:           
434:                           // Reset the Ack flag
435:                           I2C1_ACKNOWLEDGE_STATUS_BIT = 0;
021A  9C97     BCF SSP1CON2, 6, ACCESS
436:           
437:                           // Send a stop flag and go back to idle
438:                           I2C1_Stop(I2C1_DATA_NO_ACK);
021C  0E05     MOVLW 0x5
021E  EC34     CALL 0x668, 0
0220  F003     NOP
439:           
440:                       }
0222  0012     RETURN 0
441:                       else
442:                       {
443:                           // Did we send them all ?
444:                           if(i2c_bytes_left-- == 0U)
0224  061A     DECF i2c_bytes_left, F, ACCESS
0226  281A     INCF i2c_bytes_left, W, ACCESS
0228  A4D8     BTFSS STATUS, 2, ACCESS
022A  D00E     BRA 0x248
445:                           {
446:                               // yup sent them all!
447:           
448:                               // update the trb pointer
449:                               p_i2c1_trb_current++;
022C  0E06     MOVLW 0x6
022E  2611     ADDWF p_i2c1_trb_current, F, ACCESS
0230  0E00     MOVLW 0x0
0232  2212     ADDWFC 0x12, F, ACCESS
450:           
451:                               // are we done with this string of requests?
452:                               if(--i2c1_trb_count == 0)
0234  2E1B     DECFSZ i2c1_trb_count, F, ACCESS
0236  D004     BRA 0x240
453:                               {
454:                                   I2C1_Stop(I2C1_MESSAGE_COMPLETE);
0238  0E00     MOVLW 0x0
023A  EC34     CALL 0x668, 0
023C  F003     NOP
455:                               }
023E  0012     RETURN 0
456:                               else
457:                               {
458:                                   // no!, there are more TRB to be sent.
459:                                   //I2C1_START_CONDITION_ENABLE_BIT = 1;
460:           
461:                                   // In some cases, the slave may require
462:                                   // a restart instead of a start. So use this one
463:                                   // instead.
464:                                   I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
0240  8297     BSF SSP1CON2, 1, ACCESS
465:           
466:                                   // start the i2c request
467:                                   i2c1_state = S_MASTER_SEND_ADDR;
0242  0E02     MOVLW 0x2
0244  6E1C     MOVWF i2c1_state, ACCESS
468:           
469:                               }
470:                           }
0246  0012     RETURN 0
471:                           else
472:                           {
473:                               // Grab the next data to transmit
474:                               I2C1_TRANSMIT_REG = *pi2c_buf_ptr++;
0248  C00D     MOVFF pi2c_buf_ptr, FSR2
024A  FFD9     NOP
024C  C00E     MOVFF 0xE, FSR2H
024E  FFDA     NOP
0250  50DF     MOVF INDF2, W, ACCESS
0252  6E92     MOVWF SSP1BUF, ACCESS
0254  4A0D     INFSNZ pi2c_buf_ptr, F, ACCESS
0256  2A0E     INCF 0xE, F, ACCESS
475:                           }
476:                       }
477:                       break;
0258  0012     RETURN 0
478:           
479:                   case S_MASTER_ACK_ADDR:
480:           
481:                       /* Make sure the previous byte was acknowledged */
482:                       if(I2C1_ACKNOWLEDGE_STATUS_BIT)
025A  AC97     BTFSS SSP1CON2, 6, ACCESS
025C  D006     BRA 0x26A
483:                       {
484:           
485:                           // Transmission was not acknowledged
486:                           i2c1_object.i2cErrors++;
025E  2A07     INCF 0x7, F, ACCESS
487:           
488:                           // Send a stop flag and go back to idle
489:                           I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
0260  0E04     MOVLW 0x4
0262  EC34     CALL 0x668, 0
0264  F003     NOP
490:           
491:                           // Reset the Ack flag
492:                           I2C1_ACKNOWLEDGE_STATUS_BIT = 0;
0266  9C97     BCF SSP1CON2, 6, ACCESS
493:                       }
0268  0012     RETURN 0
494:                       else
495:                       {
496:                           I2C1_RECEIVE_ENABLE_BIT = 1;
026A  8697     BSF SSP1CON2, 3, ACCESS
497:                           i2c1_state = S_MASTER_ACK_RCV_DATA;
026C  0E08     MOVLW 0x8
026E  6E1C     MOVWF i2c1_state, ACCESS
498:                       }
499:                       break;
0270  0012     RETURN 0
500:           
501:                   case S_MASTER_RCV_DATA:
502:           
503:                       /* Acknowledge is completed.  Time for more data */
504:           
505:                       // Next thing is to ack the data
506:                       i2c1_state = S_MASTER_ACK_RCV_DATA;
0272  0E08     MOVLW 0x8
0274  6E1C     MOVWF i2c1_state, ACCESS
507:           
508:                       // Set up to receive a byte of data
509:                       I2C1_RECEIVE_ENABLE_BIT = 1;
0276  8697     BSF SSP1CON2, 3, ACCESS
510:           
511:                       break;
0278  0012     RETURN 0
512:           
513:                   case S_MASTER_ACK_RCV_DATA:
514:           
515:                       // Grab the byte of data received and acknowledge it
516:                       *pi2c_buf_ptr++ = I2C1_RECEIVE_REG;
027A  C00D     MOVFF pi2c_buf_ptr, FSR2
027C  FFD9     NOP
027E  C00E     MOVFF 0xE, FSR2H
0280  FFDA     NOP
0282  CF92     MOVFF SSP1BUF, INDF2
0284  FFDF     NOP
0286  4A0D     INFSNZ pi2c_buf_ptr, F, ACCESS
0288  2A0E     INCF 0xE, F, ACCESS
517:           
518:                       // Check if we received them all?
519:                       if(--i2c_bytes_left)
028A  0E01     MOVLW 0x1
028C  5E1A     SUBWF i2c_bytes_left, F, ACCESS
028E  B4D8     BTFSC STATUS, 2, ACCESS
0290  D004     BRA 0x29A
520:                       {
521:           
522:                           /* No, there's more to receive */
523:           
524:                           // No, bit 7 is clear.  Data is ok
525:                           // Set the flag to acknowledge the data
526:                           I2C1_ACKNOWLEDGE_DATA_BIT = 0;
0292  9A97     BCF SSP1CON2, 5, ACCESS
527:           
528:                           // Wait for the acknowledge to complete, then get more
529:                           i2c1_state = S_MASTER_RCV_DATA;
0294  0E06     MOVLW 0x6
0296  6E1C     MOVWF i2c1_state, ACCESS
530:                       }
0298  D003     BRA 0x2A0
531:                       else
532:                       {
533:           
534:                           // Yes, it's the last byte.  Don't ack it
535:                           // Flag that we will nak the data
536:                           I2C1_ACKNOWLEDGE_DATA_BIT = 1;
029A  8A97     BSF SSP1CON2, 5, ACCESS
537:           
538:                           I2C1_FunctionComplete();
029C  ECEC     CALL 0x7D8, 0
029E  F003     NOP
539:                       }
540:           
541:                       // Initiate the acknowledge
542:                       I2C1_ACKNOWLEDGE_ENABLE_BIT = 1;
02A0  8897     BSF SSP1CON2, 4, ACCESS
543:                       break;
02A2  0012     RETURN 0
544:           
545:                   case S_MASTER_RCV_STOP:                
546:                   case S_MASTER_SEND_STOP:
547:           
548:                       // Send the stop flag
549:                       I2C1_Stop(I2C1_MESSAGE_COMPLETE);
02A4  0E00     MOVLW 0x0
02A6  EC34     CALL 0x668, 0
02A8  F003     NOP
550:                       break;
02AA  0012     RETURN 0
551:           
552:                   default:
553:           
554:                       // This case should not happen, if it does then
555:                       // terminate the transfer
556:                       i2c1_object.i2cErrors++;
02AC  2A07     INCF 0x7, F, ACCESS
557:                       I2C1_Stop(I2C1_LOST_STATE);
02AE  0E06     MOVLW 0x6
02B0  EC34     CALL 0x668, 0
02B2  F003     NOP
558:                       break;
559:           
560:               }
02B4  0012     RETURN 0
02B6  501C     MOVF i2c1_state, W, ACCESS
02B8  0A00     XORLW 0x0
02BA  B4D8     BTFSC STATUS, 2, ACCESS
02BC  D71B     BRA 0xF4
02BE  0A01     XORLW 0x1
02C0  B4D8     BTFSC STATUS, 2, ACCESS
02C2  D749     BRA 0x156
02C4  0A03     XORLW 0x3
02C6  B4D8     BTFSC STATUS, 2, ACCESS
02C8  D77E     BRA 0x1C6
02CA  0A01     XORLW 0x1
02CC  B4D8     BTFSC STATUS, 2, ACCESS
02CE  D7A2     BRA 0x214
02D0  0A07     XORLW 0x7
02D2  B4D8     BTFSC STATUS, 2, ACCESS
02D4  D7E7     BRA 0x2A4
02D6  0A01     XORLW 0x1
02D8  B4D8     BTFSC STATUS, 2, ACCESS
02DA  D7BF     BRA 0x25A
02DC  0A03     XORLW 0x3
02DE  B4D8     BTFSC STATUS, 2, ACCESS
02E0  D7C8     BRA 0x272
02E2  0A01     XORLW 0x1
02E4  B4D8     BTFSC STATUS, 2, ACCESS
02E6  D7DE     BRA 0x2A4
02E8  0A0F     XORLW 0xF
02EA  B4D8     BTFSC STATUS, 2, ACCESS
02EC  D7C6     BRA 0x27A
02EE  0A02     XORLW 0x2
02F0  B4D8     BTFSC STATUS, 2, ACCESS
02F2  D735     BRA 0x15E
02F4  0A01     XORLW 0x1
02F6  B4D8     BTFSC STATUS, 2, ACCESS
02F8  D748     BRA 0x18A
02FA  D7D8     BRA 0x2AC
561:           }
562:           
563:           void I2C1_FunctionComplete(void)
564:           {
565:           
566:               // update the trb pointer
567:               p_i2c1_trb_current++;
07D8  0E06     MOVLW 0x6
07DA  2611     ADDWF p_i2c1_trb_current, F, ACCESS
07DC  0E00     MOVLW 0x0
07DE  2212     ADDWFC 0x12, F, ACCESS
568:           
569:               // are we done with this string of requests?
570:               if(--i2c1_trb_count == 0)
07E0  2E1B     DECFSZ i2c1_trb_count, F, ACCESS
07E2  D003     BRA 0x7EA
571:               {
572:                   i2c1_state = S_MASTER_SEND_STOP;
07E4  0E04     MOVLW 0x4
07E6  6E1C     MOVWF i2c1_state, ACCESS
573:               }
07E8  0012     RETURN 0
574:               else
575:               {
576:                   i2c1_state = S_MASTER_RESTART;
07EA  0E01     MOVLW 0x1
07EC  6E1C     MOVWF i2c1_state, ACCESS
07EE  0012     RETURN 0
577:               }
578:           
579:           }
580:           
581:           void I2C1_Stop(I2C1_MESSAGE_STATUS completion_code)
0668  6E33     MOVWF completion_code, ACCESS
582:           {
583:               // then send a stop
584:               I2C1_STOP_CONDITION_ENABLE_BIT = 1;
066A  8497     BSF SSP1CON2, 2, ACCESS
585:           
586:               // make sure the flag pointer is not NULL
587:               if (p_i2c1_current->pTrFlag != NULL)
066C  EE20     LFSR 2, 0x3
066E  F003     NOP
0670  500F     MOVF p_i2c1_current, W, ACCESS
0672  26D9     ADDWF FSR2, F, ACCESS
0674  5010     MOVF 0x10, W, ACCESS
0676  22DA     ADDWFC FSR2H, F, ACCESS
0678  50DE     MOVF POSTINC2, W, ACCESS
067A  10DE     IORWF POSTINC2, W, ACCESS
067C  B4D8     BTFSC STATUS, 2, ACCESS
067E  D010     BRA 0x6A0
588:               {
589:                   // update the flag with the completion code
590:                   *(p_i2c1_current->pTrFlag) = completion_code;
0680  EE20     LFSR 2, 0x3
0682  F003     NOP
0684  500F     MOVF p_i2c1_current, W, ACCESS
0686  26D9     ADDWF FSR2, F, ACCESS
0688  5010     MOVF 0x10, W, ACCESS
068A  22DA     ADDWFC FSR2H, F, ACCESS
068C  CFDE     MOVFF POSTINC2, __pcstackCOMRAM
068E  F031     NOP
0690  CFDD     MOVFF POSTDEC2, pwm
0692  F032     NOP
0694  C031     MOVFF __pcstackCOMRAM, FSR2
0696  FFD9     NOP
0698  C032     MOVFF pwm, FSR2H
069A  FFDA     NOP
069C  C033     MOVFF completion_code, INDF2
069E  FFDF     NOP
591:               }
592:           
593:               // Done, back to idle
594:               i2c1_state = S_MASTER_IDLE;
06A0  0E00     MOVLW 0x0
06A2  6E1C     MOVWF i2c1_state, ACCESS
595:               
596:           }
06A4  0012     RETURN 0
597:           
598:           void I2C1_MasterWrite(
599:                                           uint8_t *pdata,
600:                                           uint8_t length,
601:                                           uint16_t address,
602:                                           I2C1_MESSAGE_STATUS *pflag)
603:           {
604:               static I2C1_TRANSACTION_REQUEST_BLOCK   trBlock;
605:           
606:               // check if there is space in the queue
607:               if (i2c1_object.trStatus.s.full != true)
608:               {
609:                   I2C1_MasterWriteTRBBuild(&trBlock, pdata, length, address);
610:                   I2C1_MasterTRBInsert(1, &trBlock, pflag);
611:               }
612:               else
613:               {
614:                   *pflag = I2C1_MESSAGE_FAIL;
615:               }
616:           
617:           }
618:           
619:           void I2C1_MasterRead(
620:                                           uint8_t *pdata,
621:                                           uint8_t length,
622:                                           uint16_t address,
623:                                           I2C1_MESSAGE_STATUS *pflag)
624:           {
625:               static I2C1_TRANSACTION_REQUEST_BLOCK   trBlock;
626:           
627:           
628:               // check if there is space in the queue
629:               if (i2c1_object.trStatus.s.full != true)
630:               {
631:                   I2C1_MasterReadTRBBuild(&trBlock, pdata, length, address);
632:                   I2C1_MasterTRBInsert(1, &trBlock, pflag);
633:               }
634:               else
635:               {
636:                   *pflag = I2C1_MESSAGE_FAIL;
637:               }
638:           
639:           }
640:           
641:           void I2C1_MasterTRBInsert(
642:                                           uint8_t count,
643:                                           I2C1_TRANSACTION_REQUEST_BLOCK *ptrb_list,
644:                                           I2C1_MESSAGE_STATUS *pflag)
645:           {
646:           
647:               // check if there is space in the queue
648:               if (i2c1_object.trStatus.s.full != true)
649:               {
650:                   *pflag = I2C1_MESSAGE_PENDING;
651:           
652:                   i2c1_object.pTrTail->ptrb_list = ptrb_list;
653:                   i2c1_object.pTrTail->count     = count;
654:                   i2c1_object.pTrTail->pTrFlag   = pflag;
655:                   i2c1_object.pTrTail++;
656:           
657:                   // check if the end of the array is reached
658:                   if (i2c1_object.pTrTail == (i2c1_tr_queue + I2C1_CONFIG_TR_QUEUE_LENGTH))
659:                   {
660:                       // adjust to restart at the beginning of the array
661:                       i2c1_object.pTrTail = i2c1_tr_queue;
662:                   }
663:           
664:                   // since we added one item to be processed, we know
665:                   // it is not empty, so set the empty status to false
666:                   i2c1_object.trStatus.s.empty = false;
667:           
668:                   // check if full
669:                   if (i2c1_object.pTrHead == i2c1_object.pTrTail)
670:                   {
671:                       // it is full, set the full status to true
672:                       i2c1_object.trStatus.s.full = true;
673:                   }
674:           
675:               }
676:               else
677:               {
678:                   *pflag = I2C1_MESSAGE_FAIL;
679:               }
680:           
681:               // for interrupt based
682:               if (*pflag == I2C1_MESSAGE_PENDING)
683:               {
684:                   while(i2c1_state != S_MASTER_IDLE);
685:                   {
686:                       // force the task to run since we know that the queue has
687:                       // something that needs to be sent
688:                       PIR3bits.SSP1IF = true;
689:                   }
690:               }   // block until request is complete
691:           
692:           }
693:           
694:           void I2C1_MasterReadTRBBuild(
695:                                           I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
696:                                           uint8_t *pdata,
697:                                           uint8_t length,
698:                                           uint16_t address)
699:           {
700:               ptrb->address  = address << 1;
701:               // make this a read
702:               ptrb->address |= 0x01;
703:               ptrb->length   = length;
704:               ptrb->pbuffer  = pdata;
705:           }
706:           
707:           void I2C1_MasterWriteTRBBuild(
708:                                           I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
709:                                           uint8_t *pdata,
710:                                           uint8_t length,
711:                                           uint16_t address)
712:           {
713:               ptrb->address = address << 1;
714:               ptrb->length  = length;
715:               ptrb->pbuffer = pdata;
716:           }
717:           
718:           bool I2C1_MasterQueueIsEmpty(void)
719:           {
720:               return(i2c1_object.trStatus.s.empty);
721:           }
722:           
723:           bool I2C1_MasterQueueIsFull(void)
724:           {
725:               return(i2c1_object.trStatus.s.full);
726:           }        
727:                   
728:           void I2C1_BusCollisionISR( void )
729:           {
730:               // enter bus collision handling code here
731:           }        
0832  0012     RETURN 0
732:                   
733:                   
734:           /**
735:            End of File
736:           */
---  /home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/main.c  --------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using MPLAB(c) Code Configurator
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC18F46K40
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:             */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:             */
45:            
46:            #include "mcc_generated_files/mcc.h"
47:            #include "encoder.h"
48:            #include "leds.h"
49:            
50:            /*
51:                                     Main application
52:             */
53:            void main(void) {
54:                // Initialize the device
55:                SYSTEM_Initialize();
0612  ECF8     CALL 0x7F0, 0
0614  F003     NOP
56:                LEDS_Initialize();
0616  EC86     CALL 0x70C, 0
0618  F003     NOP
57:            
58:                IO_RB5_SetLow();
061A  9A84     BCF LATB, 5, ACCESS
59:                __delay_ms(2);
061C  0E2A     MOVLW 0x2A
061E  0100     MOVLB 0x0
0620  6F8D     MOVWF 0x8D, BANKED
0622  0E8D     MOVLW 0x8D
0624  2EE8     DECFSZ WREG, F, ACCESS
0626  D7FE     BRA 0x624
0628  2F8D     DECFSZ 0x8D, F, BANKED
062A  D7FC     BRA 0x624
062C  D000     BRA 0x62E
60:                IO_RB5_SetHigh();
062E  8A84     BSF LATB, 5, ACCESS
61:            
62:                TMR0_SetInterruptHandler(TMR0_EncoderInterruptHandler);
0630  0EE4     MOVLW 0xE4
0632  0100     MOVLB 0x0
0634  6F88     MOVWF __pcstackBANK0, BANKED
0636  0E04     MOVLW 0x4
0638  0100     MOVLB 0x0
063A  6F89     MOVWF pwm, BANKED
063C  EC0B     CALL 0x816, 0
063E  F004     NOP
63:            
64:                // If using interrupts in PIC18 High/Low Priority Mode you need to enable the Global High and Low Interrupts
65:                // If using interrupts in PIC Mid-Range Compatibility Mode you need to enable the Global and Peripheral Interrupts
66:                // Use the following macros to:
67:            
68:                // Enable high priority global interrupts
69:                //INTERRUPT_GlobalInterruptHighEnable();
70:            
71:                // Enable low priority global interrupts.
72:                //INTERRUPT_GlobalInterruptLowEnable();
73:            
74:                // Disable high priority global interrupts
75:                //INTERRUPT_GlobalInterruptHighDisable();
76:            
77:                // Disable low priority global interrupts.
78:                //INTERRUPT_GlobalInterruptLowDisable();
79:            
80:                // Enable the Global Interrupts
81:                INTERRUPT_GlobalInterruptEnable();
0640  8EF2     BSF INTCON, 7, ACCESS
82:            
83:                // Enable the Peripheral Interrupts
84:                INTERRUPT_PeripheralInterruptEnable();
0642  8CF2     BSF INTCON, 6, ACCESS
85:            
86:                // Disable the Global Interrupts
87:                //INTERRUPT_GlobalInterruptDisable();
88:            
89:                // Disable the Peripheral Interrupts
90:                //INTERRUPT_PeripheralInterruptDisable();
91:            
92:                __delay_ms(100);
0644  0E09     MOVLW 0x9
0646  0100     MOVLB 0x0
0648  6F8E     MOVWF 0x8E, BANKED
064A  0E1E     MOVLW 0x1E
064C  0100     MOVLB 0x0
064E  6F8D     MOVWF 0x8D, BANKED
0650  0EE4     MOVLW 0xE4
0652  2EE8     DECFSZ WREG, F, ACCESS
0654  D7FE     BRA 0x652
0656  2F8D     DECFSZ 0x8D, F, BANKED
0658  D7FC     BRA 0x652
065A  2F8E     DECFSZ 0x8E, F, BANKED
065C  D7FA     BRA 0x652
065E  F000     NOP
93:                IO_RB5_SetLow();
0660  9A84     BCF LATB, 5, ACCESS
94:            
95:                while (1) {
0666  D7FD     BRA 0x662
96:                    DecodePushEncoder();
0662  EC7E     CALL 0x2FC, 0
0664  F001     NOP
0666  D7FD     BRA 0x662
97:                }
98:            }
99:            /**
100:            End of File
101:            */
---  /home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/leds.c  --------------------------------
1:             #include "mcc_generated_files/mcc.h"
2:             #include "leds.h"
3:             
4:             #define TLC_5947_CHANNELS   COLORS * 8
5:             #define TLC_5947_PWM_BITS   12
6:             
7:             static uint8_t pwmTable[3 * 8]; // RGB PWM values for 8 leds
8:             
9:             void LEDS_RGB(uint8_t led, uint16_t red, uint16_t green, uint16_t blue) {
10:                // 12 bits left aligned in a 16 bit word to save time during SPI bit banging
11:                pwmTable[led * COLORS + RED] = red << 4;
12:                pwmTable[led * COLORS + GREEN] = green << 4;
13:                pwmTable[led * COLORS + BLUE] = blue << 4;
14:            }
15:            
16:            void LEDS_Color(uint8_t led, uint8_t color, uint16_t pwm) {
076A  0100     MOVLB 0x0
076C  6F8B     MOVWF led, BANKED
17:                // 12 bits left aligned in a 16 bit word to save time during SPI bit banging
18:                pwmTable[led * COLORS + color] = pwm << 4;
076E  0100     MOVLB 0x0
0770  518B     MOVF led, W, BANKED
0772  0D03     MULLW 0x3
0774  0100     MOVLB 0x0
0776  5188     MOVF __pcstackBANK0, W, BANKED
0778  26F3     ADDWF PROD, F, ACCESS
077A  0E00     MOVLW 0x0
077C  22F4     ADDWFC PRODH, F, ACCESS
077E  0E60     MOVLW 0x60
0780  24F3     ADDWF PROD, W, ACCESS
0782  6ED9     MOVWF FSR2, ACCESS
0784  0E00     MOVLW 0x0
0786  20F4     ADDWFC PRODH, W, ACCESS
0788  6EDA     MOVWF FSR2H, ACCESS
078A  0100     MOVLB 0x0
078C  3989     SWAPF pwm, W, BANKED
078E  0BF0     ANDLW 0xF0
0790  6EDF     MOVWF INDF2, ACCESS
19:            }
0008  8250     BSF btemp, 1, ACCESS
0792  0012     RETURN 0
20:            
21:            void LEDS_Initialize(void) {
22:                for (uint8_t i = 0; i < TLC_5947_CHANNELS; i++) {
070C  0E00     MOVLW 0x0
070E  0100     MOVLB 0x0
0710  6F88     MOVWF __pcstackBANK0, BANKED
0712  0E17     MOVLW 0x17
0714  0100     MOVLB 0x0
0716  6588     CPFSGT __pcstackBANK0, BANKED
0718  D001     BRA 0x71C
071A  D00E     BRA 0x738
0732  0100     MOVLB 0x0
0734  2B88     INCF __pcstackBANK0, F, BANKED
0736  D7ED     BRA 0x712
23:                    pwmTable[i] = 0x0000u;
071C  0100     MOVLB 0x0
071E  5188     MOVF __pcstackBANK0, W, BANKED
0720  0D01     MULLW 0x1
0722  0E60     MOVLW 0x60
0724  24F3     ADDWF PROD, W, ACCESS
0726  6ED9     MOVWF FSR2, ACCESS
0728  0E00     MOVLW 0x0
072A  20F4     ADDWFC PRODH, W, ACCESS
072C  6EDA     MOVWF FSR2H, ACCESS
072E  0E00     MOVLW 0x0
0730  6EDF     MOVWF INDF2, ACCESS
24:                }
25:                TLC_5947_BLANK_SetLow(); // Enable output
0738  9287     BCF LATE, 1, ACCESS
073A  0012     RETURN 0
26:            }
27:            
28:            void LEDS_Shutdown(void) {
29:                TLC_5947_BLANK_SetHigh(); // Disable output
30:            }
31:            
32:            void LEDS_Tx_Buffer(void) {
33:                uint8_t pwm; // 12 bit channel PWM value
34:                uint8_t chBit; // bit pointer for SPI, MSB first (11 -> 0)
35:                uint8_t channel; // channel pointer for SPI, last channel first (23 -> 0)
36:            
37:                IO_RB5_SetHigh(); // Debug signaling
06A6  8A84     BSF LATB, 5, ACCESS
38:            
39:                channel = TLC_5947_CHANNELS - 1; // Last channel first
06A8  0E17     MOVLW 0x17
06AA  6E33     MOVWF completion_code, ACCESS
40:                do {
41:                    pwm = pwmTable[channel];
06AC  5033     MOVF completion_code, W, ACCESS
06AE  0D01     MULLW 0x1
06B0  0E60     MOVLW 0x60
06B2  24F3     ADDWF PROD, W, ACCESS
06B4  6ED9     MOVWF FSR2, ACCESS
06B6  0E00     MOVLW 0x0
06B8  20F4     ADDWFC PRODH, W, ACCESS
06BA  6EDA     MOVWF FSR2H, ACCESS
06BC  50DF     MOVF INDF2, W, ACCESS
06BE  6E32     MOVWF pwm, ACCESS
42:                    chBit = TLC_5947_PWM_BITS;
06C0  0E0C     MOVLW 0xC
06C2  6E31     MOVWF __pcstackCOMRAM, ACCESS
43:                    do {
44:                        // Slightly asymmetric (2 or 3 instructions) but averages one instruction less per bit,
45:                        // marks bits on a 'scope trace and leaves SIN low at the end ov the word.
46:                        TLC_5947_SIN_SetLow(); // SPI bit banging
06C4  9684     BCF LATB, 3, ACCESS
47:                        if (pwm & 0x80u) {
06C6  BE32     BTFSC pwm, 7, ACCESS
48:                            TLC_5947_SIN_SetHigh(); // SPI bit banging
06C8  8684     BSF LATB, 3, ACCESS
49:                        } 
50:            
51:                        TLC_5947_SCLK_SetHigh(); // SPI bit banging
06CA  8484     BSF LATB, 2, ACCESS
52:                        pwm <<= 1;
06CC  90D8     BCF STATUS, 0, ACCESS
06CE  3632     RLCF pwm, F, ACCESS
53:                        TLC_5947_SCLK_SetLow(); // SPI bit banging
06D0  9484     BCF LATB, 2, ACCESS
54:                    } while (--chBit > 0);
06D2  2E31     DECFSZ __pcstackCOMRAM, F, ACCESS
06D4  D7F7     BRA 0x6C4
55:                } while (--channel >= 0);
06D6  0633     DECF completion_code, F, ACCESS
06D8  D7E9     BRA 0x6AC
56:            
57:                TLC_5947_BLANK_SetHigh(); // Disable output
58:                TLC_5947_XLAT_SetHigh(); // Latch new pwm values
59:                TLC_5947_XLAT_SetLow();
60:                TLC_5947_BLANK_SetLow(); // Enable output
61:            
62:                IO_RB5_SetLow(); // Debug signaling
63:            }
---  /home/kruntz/Work/oltreNoi/MPLABXProjects/EncoderBaySlave.X/encoder.c  -----------------------------
1:             #include "mcc_generated_files/mcc.h"
2:             #include "encoder.h"
3:             #include "leds.h"
4:             
5:             /*
6:              * Quadrature encoder transition table
7:             Transition  Valid?  Move
8:             00  0000	No      0
9:             01  0001	CCW    -1
10:            02  0010	CW      1
11:            03  0011	No      0
12:            04  0100	CW      1
13:            05  0101	No      0
14:            06  0110	No      0
15:            07  0111	CCW    -1
16:            08  1000	CCW    -1
17:            09  1001	No      0
18:            10  1010	No      0
19:            11  1011	CW      1
20:            12  1100	No      0
21:            13  1101	CW      1
22:            14  1110	CCW    -1
23:            15  1111	No      0
24:             */
25:            
26:            volatile int8_t buttonState = 0;
27:            volatile uint8_t buttonPressed = 0;
28:            volatile int8_t encoderSteps = 0;
29:            volatile uint8_t encoderPeriod = 0;
30:            
31:            static int rgb = 0;
32:            
33:            void TMR0_EncoderInterruptHandler(void) {
34:                IO_RB4_Toggle();
04E4  A884     BTFSS LATB, 4, ACCESS
04E6  D002     BRA 0x4EC
04E8  0E01     MOVLW 0x1
04EA  D001     BRA 0x4EE
04EC  0E00     MOVLW 0x0
04EE  0AFF     XORLW 0xFF
04F0  6E34     MOVWF 0x34, ACCESS
04F2  3A34     SWAPF 0x34, F, ACCESS
04F4  5084     MOVF LATB, W, ACCESS
04F6  1834     XORWF 0x34, W, ACCESS
04F8  0BEF     ANDLW 0xEF
04FA  1834     XORWF 0x34, W, ACCESS
04FC  6E84     MOVWF LATB, ACCESS
35:            
36:                // ---------- Read button state
37:                static int8_t buttonStates[] = {0, 0, 0, 1, -1, 0, 0, 0};
38:                static uint8_t oldButtonState = 0;
39:            
40:                // Remember previous state
41:                oldButtonState <<= 1;
04FE  90D8     BCF STATUS, 0, ACCESS
0500  3614     RLCF oldButtonState, F, ACCESS
42:                // Add actual state
43:                oldButtonState |= ENC_00_P_GetValue();
0502  A08D     BTFSS PORTA, 0, ACCESS
0504  D002     BRA 0x50A
0506  0E01     MOVLW 0x1
0508  D001     BRA 0x50C
050A  0E00     MOVLW 0x0
050C  1214     IORWF oldButtonState, F, ACCESS
44:                // Indexed state (de-bounce with at least two consecutive identical states)
45:                buttonState = buttonStates[(oldButtonState & 0x07)];
050E  5014     MOVF oldButtonState, W, ACCESS
0510  0B07     ANDLW 0x7
0512  6E34     MOVWF 0x34, ACCESS
0514  6A35     CLRF 0x35, ACCESS
0516  0E46     MOVLW 0x46
0518  2434     ADDWF 0x34, W, ACCESS
051A  6ED9     MOVWF FSR2, ACCESS
051C  0E00     MOVLW 0x0
051E  2035     ADDWFC 0x35, W, ACCESS
0520  6EDA     MOVWF FSR2H, ACCESS
0522  50DF     MOVF INDF2, W, ACCESS
0524  6E18     MOVWF buttonState, ACCESS
46:                if (buttonState == 1) {
0526  0418     DECF buttonState, W, ACCESS
0528  A4D8     BTFSS STATUS, 2, ACCESS
052A  D002     BRA 0x530
47:                    buttonPressed = 1;
052C  0E01     MOVLW 0x1
052E  6E17     MOVWF buttonPressed, ACCESS
48:                }
49:            
50:                // ---------- Read encoder state
51:                static int8_t encoderStates[] = {0, -1, 1, 0, 1, 0, 0, -1, -1, 0, 0, 1, 0, 1, -1, 0};
52:                static uint8_t oldEncoderState = 0;
53:            
54:                // Remember previous state
55:                oldEncoderState <<= 2;
0530  90D8     BCF STATUS, 0, ACCESS
0532  3613     RLCF oldEncoderState, F, ACCESS
0534  90D8     BCF STATUS, 0, ACCESS
0536  3613     RLCF oldEncoderState, F, ACCESS
56:                // Add actual state
57:                oldEncoderState |= (ENC_00_B_GetValue());
0538  A28F     BTFSS PORTC, 1, ACCESS
053A  D002     BRA 0x540
053C  0E01     MOVLW 0x1
053E  D001     BRA 0x542
0540  0E00     MOVLW 0x0
0542  1213     IORWF oldEncoderState, F, ACCESS
58:                oldEncoderState |= (ENC_00_A_GetValue() << 1);
0544  A08F     BTFSS PORTC, 0, ACCESS
0546  D003     BRA 0x54E
0548  6A34     CLRF 0x34, ACCESS
054A  2A34     INCF 0x34, F, ACCESS
054C  D001     BRA 0x550
054E  6A34     CLRF 0x34, ACCESS
0550  90D8     BCF STATUS, 0, ACCESS
0552  3434     RLCF 0x34, W, ACCESS
0554  1213     IORWF oldEncoderState, F, ACCESS
59:                // Indexed state (de-bounce with quadrature code)
60:                encoderSteps += encoderStates[(oldEncoderState & 0x0f)];
0556  5013     MOVF oldEncoderState, W, ACCESS
0558  0B0F     ANDLW 0xF
055A  6E34     MOVWF 0x34, ACCESS
055C  6A35     CLRF 0x35, ACCESS
055E  0E78     MOVLW 0x78
0560  2434     ADDWF 0x34, W, ACCESS
0562  6ED9     MOVWF FSR2, ACCESS
0564  0E00     MOVLW 0x0
0566  2035     ADDWFC 0x35, W, ACCESS
0568  6EDA     MOVWF FSR2H, ACCESS
056A  50DF     MOVF INDF2, W, ACCESS
056C  2616     ADDWF encoderSteps, F, ACCESS
61:                if (encoderPeriod < UINT8_MAX) {
056E  2815     INCF encoderPeriod, W, ACCESS
0570  A4D8     BTFSS STATUS, 2, ACCESS
62:                    encoderPeriod++;
0572  2A15     INCF encoderPeriod, F, ACCESS
63:                }
64:            
65:            //    for (int i = 0; i < (encoderSteps < 0 ? (-encoderSteps) : encoderSteps); i++) {
66:                for (int i = 0; i <= rgb; i++) {
0574  0E00     MOVLW 0x0
0576  6E37     MOVWF 0x37, ACCESS
0578  0E00     MOVLW 0x0
057A  6E36     MOVWF i, ACCESS
057C  D00A     BRA 0x592
058E  4A36     INFSNZ i, F, ACCESS
0590  2A37     INCF 0x37, F, ACCESS
0592  5036     MOVF i, W, ACCESS
0594  5C0B     SUBWF rgb, W, ACCESS
0596  500C     MOVF 0xC, W, ACCESS
0598  0A80     XORLW 0x80
059A  6E34     MOVWF 0x34, ACCESS
059C  5037     MOVF 0x37, W, ACCESS
059E  0A80     XORLW 0x80
05A0  5834     SUBWFB 0x34, W, ACCESS
05A2  B0D8     BTFSC STATUS, 0, ACCESS
05A4  D7EC     BRA 0x57E
67:                    IO_RB5_SetHigh();
057E  8A84     BSF LATB, 5, ACCESS
68:                    Nop();
0580  F000     NOP
69:                    Nop();
0582  F000     NOP
70:                    Nop();
0584  F000     NOP
71:                    IO_RB5_SetLow();
0586  9A84     BCF LATB, 5, ACCESS
72:                    Nop();
0588  F000     NOP
73:                    Nop();
058A  F000     NOP
74:                    Nop();
058C  F000     NOP
75:                }
76:            
77:                LEDS_Tx_Buffer();
05A6  EC53     CALL 0x6A6, 0
05A8  F003     NOP
78:            }
05AA  0012     RETURN 0
79:            
80:            void DecodePushEncoder(void) {
81:                static uint8_t led0hi[3];
82:            
83:                if (buttonPressed) {
02FC  5017     MOVF buttonPressed, W, ACCESS
02FE  B4D8     BTFSC STATUS, 2, ACCESS
0300  D010     BRA 0x322
84:                    rgb++;
0302  4A0B     INFSNZ rgb, F, ACCESS
0304  2A0C     INCF 0xC, F, ACCESS
85:                    if (rgb > 2) {
0306  BE0C     BTFSC 0xC, 7, ACCESS
0308  D00A     BRA 0x31E
030A  500C     MOVF 0xC, W, ACCESS
030C  E104     BNZ 0x316
030E  0E03     MOVLW 0x3
0310  5C0B     SUBWF rgb, W, ACCESS
0312  A0D8     BTFSS STATUS, 0, ACCESS
0314  D004     BRA 0x31E
86:                        rgb = 0;
0316  0E00     MOVLW 0x0
0318  6E0C     MOVWF 0xC, ACCESS
031A  0E00     MOVLW 0x0
031C  6E0B     MOVWF rgb, ACCESS
87:                    }
88:                    buttonPressed = 0;
031E  0E00     MOVLW 0x0
0320  6E17     MOVWF buttonPressed, ACCESS
89:                }
90:            
91:                if (encoderSteps != 0) {
0322  5016     MOVF encoderSteps, W, ACCESS
0324  B4D8     BTFSC STATUS, 2, ACCESS
0326  0012     RETURN 0
92:                    if (encoderSteps >= 4) {
0328  5016     MOVF encoderSteps, W, ACCESS
032A  0A80     XORLW 0x80
032C  0F7C     ADDLW 0x7C
032E  A0D8     BTFSS STATUS, 0, ACCESS
0330  D034     BRA 0x39A
93:                        encoderSteps -= 4;
0332  0EFC     MOVLW 0xFC
0334  2616     ADDWF encoderSteps, F, ACCESS
94:                        //            if (encoderPeriod < SPEEDY_INTERVAL) {
95:                        //            } else {
96:                        //            }
97:            
98:                        led0hi[rgb] = led0hi[rgb] + 1;
0336  0E08     MOVLW 0x8
0338  240B     ADDWF rgb, W, ACCESS
033A  6ED9     MOVWF FSR2, ACCESS
033C  0E00     MOVLW 0x0
033E  200C     ADDWFC 0xC, W, ACCESS
0340  6EDA     MOVWF FSR2H, ACCESS
0342  0E08     MOVLW 0x8
0344  240B     ADDWF rgb, W, ACCESS
0346  6EE1     MOVWF FSR1, ACCESS
0348  0E00     MOVLW 0x0
034A  200C     ADDWFC 0xC, W, ACCESS
034C  6EE2     MOVWF FSR1H, ACCESS
034E  50E7     MOVF INDF1, W, ACCESS
0350  0100     MOVLB 0x0
0352  6F8C     MOVWF 0x8C, BANKED
0354  0100     MOVLB 0x0
0356  298C     INCF 0x8C, W, BANKED
0358  6EDF     MOVWF INDF2, ACCESS
99:                        if (led0hi[rgb] > 0x0f) {
035A  0E08     MOVLW 0x8
035C  240B     ADDWF rgb, W, ACCESS
035E  6ED9     MOVWF FSR2, ACCESS
0360  0E00     MOVLW 0x0
0362  200C     ADDWFC 0xC, W, ACCESS
0364  6EDA     MOVWF FSR2H, ACCESS
0366  0E0F     MOVLW 0xF
0368  64DF     CPFSGT INDF2, ACCESS
036A  D008     BRA 0x37C
100:                           led0hi[rgb] = 0x00;
036C  0E08     MOVLW 0x8
036E  240B     ADDWF rgb, W, ACCESS
0370  6ED9     MOVWF FSR2, ACCESS
0372  0E00     MOVLW 0x0
0374  200C     ADDWFC 0xC, W, ACCESS
0376  6EDA     MOVWF FSR2H, ACCESS
0378  0E00     MOVLW 0x0
037A  6EDF     MOVWF INDF2, ACCESS
101:                       }
102:                       LEDS_Color(0, rgb, led0hi[rgb] << 8);
037C  C00B     MOVFF rgb, __pcstackBANK0
037E  F088     NOP
0380  0E08     MOVLW 0x8
0382  240B     ADDWF rgb, W, ACCESS
0384  6ED9     MOVWF FSR2, ACCESS
0386  0E00     MOVLW 0x0
0388  200C     ADDWFC 0xC, W, ACCESS
038A  6EDA     MOVWF FSR2H, ACCESS
038C  50DF     MOVF INDF2, W, ACCESS
038E  0100     MOVLB 0x0
0390  6F8A     MOVWF 0x8A, BANKED
0392  6B89     CLRF pwm, BANKED
0394  0E00     MOVLW 0x0
0396  ECB5     CALL 0x76A, 0
0398  F003     NOP
103:           
104:                               //            encoderPeriod = 0;
105:                   }
106:                   if (encoderSteps <= -4) {
039A  5016     MOVF encoderSteps, W, ACCESS
039C  0A80     XORLW 0x80
039E  0F83     ADDLW 0x83
03A0  B0D8     BTFSC STATUS, 0, ACCESS
03A2  0012     RETURN 0
107:                       encoderSteps += 4;
03A4  0E04     MOVLW 0x4
03A6  2616     ADDWF encoderSteps, F, ACCESS
108:                       //            if (encoderPeriod < SPEEDY_INTERVAL) {
109:                       //            } else {
110:                       //            }
111:           
112:                       if (led0hi[rgb] == 0x00) {
03A8  0E08     MOVLW 0x8
03AA  240B     ADDWF rgb, W, ACCESS
03AC  6ED9     MOVWF FSR2, ACCESS
03AE  0E00     MOVLW 0x0
03B0  200C     ADDWFC 0xC, W, ACCESS
03B2  6EDA     MOVWF FSR2H, ACCESS
03B4  50DF     MOVF INDF2, W, ACCESS
03B6  A4D8     BTFSS STATUS, 2, ACCESS
03B8  D008     BRA 0x3CA
113:                           led0hi[rgb] = 0x0f;
03BA  0E08     MOVLW 0x8
03BC  240B     ADDWF rgb, W, ACCESS
03BE  6ED9     MOVWF FSR2, ACCESS
03C0  0E00     MOVLW 0x0
03C2  200C     ADDWFC 0xC, W, ACCESS
03C4  6EDA     MOVWF FSR2H, ACCESS
03C6  0E0F     MOVLW 0xF
03C8  D011     BRA 0x3EC
114:                       } else {
115:                           led0hi[rgb] = led0hi[rgb] - 1;
03CA  0E08     MOVLW 0x8
03CC  240B     ADDWF rgb, W, ACCESS
03CE  6ED9     MOVWF FSR2, ACCESS
03D0  0E00     MOVLW 0x0
03D2  200C     ADDWFC 0xC, W, ACCESS
03D4  6EDA     MOVWF FSR2H, ACCESS
03D6  0E08     MOVLW 0x8
03D8  240B     ADDWF rgb, W, ACCESS
03DA  6EE1     MOVWF FSR1, ACCESS
03DC  0E00     MOVLW 0x0
03DE  200C     ADDWFC 0xC, W, ACCESS
03E0  6EE2     MOVWF FSR1H, ACCESS
03E2  50E7     MOVF INDF1, W, ACCESS
03E4  0100     MOVLB 0x0
03E6  6F8C     MOVWF 0x8C, BANKED
03E8  0100     MOVLB 0x0
03EA  058C     DECF 0x8C, W, BANKED
03EC  6EDF     MOVWF INDF2, ACCESS
116:                       }
117:                       LEDS_Color(0, rgb, led0hi[rgb] << 8);
03EE  C00B     MOVFF rgb, __pcstackBANK0
03F0  F088     NOP
03F2  0E08     MOVLW 0x8
03F4  240B     ADDWF rgb, W, ACCESS
03F6  6ED9     MOVWF FSR2, ACCESS
03F8  0E00     MOVLW 0x0
03FA  200C     ADDWFC 0xC, W, ACCESS
03FC  6EDA     MOVWF FSR2H, ACCESS
03FE  50DF     MOVF INDF2, W, ACCESS
0400  0100     MOVLB 0x0
0402  6F8A     MOVWF 0x8A, BANKED
0404  6B89     CLRF pwm, BANKED
0406  0E00     MOVLW 0x0
0408  ECB5     CALL 0x76A, 0
040A  F003     NOP
118:           
119:                               //            encoderPeriod = 0;
120:                   }
040C  0012     RETURN 0
121:               }
122:           }
